/**
 * 
 */
package ar.com.guver.gasstation;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.EnumMap;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import net.bigpoint.assessment.gasstation.GasPump;
import net.bigpoint.assessment.gasstation.GasStation;
import net.bigpoint.assessment.gasstation.GasType;
import net.bigpoint.assessment.gasstation.exceptions.GasTooExpensiveException;
import net.bigpoint.assessment.gasstation.exceptions.NotEnoughGasException;

/**
 * @author GdelGerb
 *
 */
public class RealGasStation implements GasStation, Runnable {

	private static final int size = 3;
	private int cancellationsNoGas;
	private int cancellationsTooExpensive;
	private double totalRevenue;
	private int numberOfSales;
	
	Map<GasType, GasPump> stationGasPumps = Collections.synchronizedMap(new EnumMap<GasType, GasPump>(GasType.class));
	
	EnumMap<GasType, Double> typePriceMap = new EnumMap<>(GasType.class);
	private final BlockingQueue<CustomerRequest> customerQueue;
	ExecutorService gasRequestExecutor = Executors.newFixedThreadPool(size);
	
	public RealGasStation (BlockingQueue<CustomerRequest> sharedQueue){
		this.customerQueue = sharedQueue;
		cancellationsNoGas = 0;
		cancellationsTooExpensive = 0;
		totalRevenue = 0;
		numberOfSales = 0;
	}
	
	@Override
	public void addGasPump(GasPump pump) {
		stationGasPumps.put(pump.getGasType(), pump);
	}

	@Override
	public Collection<GasPump> getGasPumps() {
		return stationGasPumps.values();
	}

	private GasRequest associateGasPumpForRequest(GasRequest request) {
		GasPump pump = stationGasPumps.get(request.getType());
		request.setPump(pump);
		return request;
	}

	@Override
	public double getRevenue() {

		return totalRevenue;
	}

	@Override
	public int getNumberOfSales() {

		return numberOfSales;
	}

	@Override
	public int getNumberOfCancellationsNoGas() {

		return cancellationsNoGas;
	}

	@Override
	public int getNumberOfCancellationsTooExpensive() {

		return cancellationsTooExpensive;
	}

	@Override
	public double getPrice(GasType type) {
		return typePriceMap.get(type);
	}

	@Override
	public void setPrice(GasType type, double price) {
		typePriceMap.put(type, price);
	}

	@Override
	public void run() {
		// Here we do the magic. This is the consumer thread of the requests generated by the
		// CustomerProducer. 
		while (!Thread.interrupted())
		try {
			CustomerRequest request = customerQueue.take();
			double revenue = buyGas(request.getType(),request.getAmount(),request.getMaxPrice()); 
			totalRevenue += revenue;
			if (revenue > 0)
			{
				numberOfSales++;
			}
		} catch (GasTooExpensiveException ex) {
			cancellationsTooExpensive++;
		} catch (NotEnoughGasException ex) {
			cancellationsNoGas++;
		} catch (InterruptedException ex) {
			gasRequestExecutor.shutdown();
			return;
		}
	}

	@Override
	public double buyGas(GasType type, double amountInLiters,
			double maxPricePerLiter) throws NotEnoughGasException,
			GasTooExpensiveException {
		double revenue = 0;
		GasRequest request = new GasRequest(type, amountInLiters, maxPricePerLiter);
		request = associateGasPumpForRequest(request);
		if (request.getMaxPrice() < typePriceMap.get(request.getType()))
		{
			//The price of the gas is higher than customer is willing to pay
			throw new GasTooExpensiveException();
		}
		Future<Double> amountResponse = gasRequestExecutor.submit(request);
		try 
		{
		   revenue = amountResponse.get() * typePriceMap.get(request.getType());
		} catch (ExecutionException ex) {
			Throwable t = ex.getCause();
			if (t instanceof NotEnoughGasException){
				throw (NotEnoughGasException)t;
			}
			else {
				//something strange happened cause we should not be here
			}
		} catch (InterruptedException ex) {
			//do nothing.
		}
	return revenue;
	}
}
